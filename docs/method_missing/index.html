<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">

  <title>Opal: Ruby to Javascript compiler</title>

  <link href="/stylesheets/application.css" media="screen" rel="stylesheet" type="text/css" />
  <script src="/javascripts/application.js" type="text/javascript"></script>
</head>
<body>
  <nav class="navbar navbar-default opal-nav">
  <div class="container">

    <div class="navbar-header">
      <a class="navbar-brand" href="/">
        <img height='22' width='22' style='margin-top:-10%;' src='https://secure.gravatar.com/avatar/88298620949a6534d403da2e356c9339?s=420&d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-org-420.png'/>
        Opal
      </a>
    </div>

    <div class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li><a href="/docs">Documentation</a></li>
        <li><a href="/try">Try Opal now!</a></li>
        <li class="divider-vertical"></li>
        <li><p class="navbar-text"><span class="label label-info">integrations:</span></p></li>
        <li><a href="http://github.com/opal/opal-jquery">jQuery</a></li>
        <li><a href="https://github.com/opal/opal-rails#readme">Rails</a></li>
        <li><a href="https://github.com/opal/opal-rspec#readme">RSpec</a></li>
        <li><a href="https://github.com/opal/vienna#readme">Vienna</a></li>
        <li><a href="https://github.com/opal/opal-node#readme">Nodejs / RVM</a></li>
        <li><a href="https://github.com/opal/opal-todos#readme">TodoMVC</a></li>
      </ul>
    </div>

  </div>
</nav>


  <div class="container">
    <div class="row">
      <div class="col-md-3">
        <ul class="nav nav-pills nav-stacked">
          <li><a href="/docs">Opal</a></li>
          <li><a href="/docs/getting_started">Getting Started</a></li>
          <li><a href="/docs/generated_javascript">Generated Code</a></li>
          <li><a href="/docs/method_missing">method_missing support</a></li>
          <li><a href="/docs/using_ruby_from_javascript">Accessing Ruby methods</a></li>
          <li><a href="/docs/using_sprockets">Sprockets Integration</a></li>
          <li><a href="/docs/static_applications">Building Static Apps</a></li>
        </ul>
      </div>

      <div class="col-md-9">
        <h1>Method Missing in Opal</h1>

<p>Opal supports <code>method_missing</code>. This is a key feature of ruby, and opal wouldn&#39;t be much use without it! This page details the implementation of <code>method_missing</code> for Opal.</p>

<h2>Method dispatches</h2>

<p>Firstly, a ruby call <code>foo.bar 1, 2, 3</code> is compiled into the following javascript:</p>
<pre class="highlight javascript"><span class="nx">foo</span><span class="p">.</span><span class="nx">$bar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre>
<p>This should be pretty easy to read. The <code>bar</code> method has a <code>$</code> prefix just to distinguish it from underlying javascript properties, as well as ruby ivars. Methods are compiled like this to make the generated code really readable.</p>

<h2>Handling method_missing</h2>

<p>Javascript does not have an equivalent of <code>method_missing</code>, so how do we handle it? If a function is missing in javascript, then a language level exception will be raised.</p>

<p>To get around this, we make use of our compiler. During parsing, we collect a list of all method calls made inside a ruby file, and this gives us a list of all possible method calls. We then add stub methods to the root object prototype (an opal object, not the global javascript Object) which will proxy our method missing calls for us.</p>

<p>For example, assume the following ruby script:</p>
<pre class="highlight ruby"><span class="n">first</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>
<span class="n">second</span> <span class="s2">&quot;wow&quot;</span><span class="nf">.to_sym</span>
</pre>
<p>After parsing, we know we only ever call 3 methods: <code>[:first, :second, :to_sym]</code>. So, imagine we could just add these 3 methods to <code>BasicObject</code> in ruby, we would get something like this:</p>
<pre class="highlight ruby"><span class="k">class </span><span class="nc">BasicObject</span>
  <span class="k">def </span><span class="nf">first</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="nb">method_missing</span><span class="p">(</span><span class="ss">:first</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def </span><span class="nf">second</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="nb">method_missing</span><span class="p">(</span><span class="ss">:second</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def </span><span class="nf">to_sym</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="nb">method_missing</span><span class="p">(</span><span class="ss">:to_sym</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
<p>It is obvious from here, that unless an object defines any given method, it will always resort in a dispatch to <code>method_missing</code> from one of our defined stub methods. This is how we get <code>method_missing</code> in opal.</p>

<h2>Optimising generated code</h2>

<p>To optimise the generated code slightly, we reduce the code output from the compiler into the following javascript:</p>
<pre class="highlight javascript"><span class="nx">Opal</span><span class="p">.</span><span class="nx">add_stubs</span><span class="p">([</span><span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="s2">&quot;second&quot;</span><span class="p">,</span> <span class="s2">&quot;to_sym&quot;</span><span class="p">]);</span>
</pre>
<p>You will see this at the top of all your generated javascript files. This will add a stub method for all methods used in your file.</p>

<h2>Alternative approaches</h2>

<p>The old approach was to inline <code>method_missing</code> calls by checking for a method on <strong>every method dispatch</strong>. This is still supported via a parser option, but not recommended.</p>

      </div>
    </div>
  </div>

  <!-- GOOGLE ANALYTICS -->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-35688734-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
<footer style='padding: 70px 0;
 margin-top: 70px;
 border-top: 1px solid
 #e5e5e5;
 background-color:
 #f5f5f5;text-align:center'>
     <a style="color: #888;" href="/license">License</a> â€¢
     <a style="color: #888;" href="https://github.com/opal/opal/graphs/contributors">Contributors</a>
</footer>


  <script>
    $('a[href="'+location.pathname.replace(/\/$/,'')+'"]').parent().addClass('active')
  </script>
</body>
</html>
